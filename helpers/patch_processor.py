import datetime

import SimpleITK as sitk
import numpy as np
import os

from pe.helpers.shared_helpers import SharedHelpers

sh = SharedHelpers()


class PatchProcessor:
    """
    This is the Patch Processor helper class. This hosts methods
    that helps up get patches from images and validate them
    """

    def validate_patch(self, candidate_df, predicted_mask, image_gt):
        """
        Validates the patches generated by the Generator - Only if the GT exists
        *** It is important to understand why I am throwing away anything that is inside the GT bounding bos as invaid.
            Our GT is very sparse and there is no way to know if candidates generated withing the bounding box
            (or even outside the GT bounding box) are valid or invalid. I would rather take candidates from negative
            cases to do classification. However, this does help in eradicating nuisance candidates that are outside
            the probable (assume/or not that nothing exists outside the bounding box) area.

        :param candidate_df: the candidates df
        :param predicted_mask: the predicted mask
        :param image_gt: ground truth
        :return: updated candidate_df
        """

        # Get the image_gt label stat
        image_gt_label_stat = sitk.LabelShapeStatisticsImageFilter()
        image_gt_label_stat.Execute(image_gt)

        image_gt_bounding_boxs = []
        for label_number in image_gt_label_stat.GetLabels():
            bounding_box = image_gt_label_stat.GetBoundingBox(label_number)
            image_gt_bounding_boxs.append(bounding_box)

        # Iterate each row of candidate_df- each candidate patch
        for index, row in candidate_df.iterrows():
            patch_bounding_box = {'xmin': row['bounding_box'][0],
                                  'xmax': row['bounding_box'][0] + row['bounding_box'][3],
                                  'ymin': row['bounding_box'][1],
                                  'ymax': row['bounding_box'][1] + row['bounding_box'][4],
                                  'zmin': row['bounding_box'][2],
                                  'zmax': row['bounding_box'][2] + row['bounding_box'][5]}

            # Set the is_patch_valid flag to false
            is_patch_valid = False

            for image_gt_bounding_box in image_gt_bounding_boxs:
                gt_bounding_box = {'xmin': image_gt_bounding_box[0],
                                   'xmax': image_gt_bounding_box[0] + image_gt_bounding_box[3],
                                   'ymin': image_gt_bounding_box[1],
                                   'ymax': image_gt_bounding_box[1] + image_gt_bounding_box[4],
                                   'zmin': image_gt_bounding_box[2],
                                   'zmax': image_gt_bounding_box[2] + image_gt_bounding_box[5]}

                if (patch_bounding_box['xmax'] >= gt_bounding_box['xmin'] and gt_bounding_box['xmax'] >=
                    patch_bounding_box['xmin']) and \
                        (patch_bounding_box['ymax'] >= gt_bounding_box['ymin'] and gt_bounding_box['ymax'] >=
                         patch_bounding_box['ymin']) and \
                        (patch_bounding_box['zmax'] >= gt_bounding_box['zmin'] and gt_bounding_box['zmax'] >=
                         patch_bounding_box['zmin']):
                    is_patch_valid = True

            # Update candidate validation
            candidate_df.loc[index, 'is_patch_valid'] = is_patch_valid

        return candidate_df

    def get_patch_image(self, image, centroid, bounding_box, classification_patch_size, patch_margin,
                        pixeldefaultvalue=-1024, interpolator=sitk.sitkLinear):
        sh.print("patch_margin", patch_margin, bounding_box)
        resampler = sitk.ResampleImageFilter()
        transform = sitk.Transform(3, sitk.sitkIdentity)
        outputSize = classification_patch_size * 3

        center = np.array([float(centroid[0]), float(centroid[1]), float(centroid[2])])

        patch_boxX = float(bounding_box[3]) * image.GetSpacing()[0]
        patch_boxY = float(bounding_box[4]) * image.GetSpacing()[1]
        patch_boxZ = float(bounding_box[5]) * image.GetSpacing()[2]

        patch_diam = np.max([patch_boxX, patch_boxY, patch_boxZ, 5.0])
        #  patch_diam = np.maximum(patch_box, 5.0)
        outputspacing = np.array([(1. + 2. * patch_margin) * patch_diam / 64] * 3)

        origin = []
        for i in np.arange(3):
            origin.append(center[i] - outputspacing[i] * (outputSize[i] - 1) * .5)

        resampler.SetTransform(transform)

        resampler.SetInterpolator(interpolator)
        resampler.SetOutputOrigin(tuple(origin))
        resampler.SetOutputDirection(image.GetDirection())
        resampler.SetOutputPixelType(image.GetPixelIDValue())
        resampler.SetOutputSpacing(outputspacing)
        resampler.SetSize(outputSize)
        resampler.SetDefaultPixelValue(pixeldefaultvalue)
        return resampler.Execute(image)

    def get_patch_image_exp(self, image, centroid, bounding_box, classification_patch_size, patch_margin=10,
                            pixeldefaultvalue=-1024, interpolator=sitk.sitkLinear):

        patch_diam = np.max([bounding_box[3], bounding_box[4], bounding_box[5], 5.0])
        half_patch_diam = int(patch_diam / 2) + patch_margin
        center = np.array([
            (bounding_box[0] + int(bounding_box[3] / 2)),
            (bounding_box[1] + int(bounding_box[4] / 2)),
            (bounding_box[2] + int(bounding_box[5] / 2))
        ])
        # Calculate index
        x_min_idx = max(center[0] - half_patch_diam, 0)
        x_max_idx = min(center[0] + half_patch_diam, image.GetSize()[0])

        y_min_idx = max(center[1] - half_patch_diam, 0)
        y_max_idx = min(center[1] + half_patch_diam, image.GetSize()[1])

        # We choose to interpolate the z index just from the number of slices
        # Most annotatins have 1 slice - we should have atleast 3 (best guess!)
        if bounding_box[5] == 1:
            z_min_idx = bounding_box[2] - 1
            z_max_idx = bounding_box[2] + 1
        else:
            z_min_idx = bounding_box[2]
            z_max_idx = min(bounding_box[2] + bounding_box[5], image.GetSize()[2])

        if not min((x_min_idx, x_max_idx, y_min_idx, y_max_idx, z_min_idx, z_max_idx)) >= 0 or not min(
                ((x_max_idx - x_min_idx), (y_max_idx - y_min_idx), (z_max_idx - z_min_idx))) >= 2:
            # sh.print('Setting image as null image', bounding_box,
            #          (x_min_idx, x_max_idx, y_min_idx, y_max_idx, z_min_idx, z_max_idx))
            zeros = np.zeros((64, 64, 64, 1), dtype=np.float)
            # zeros.fill(pixeldefaultvalue)
            patch_image = sitk.GetImageFromArray(zeros)
        else:
            patch_image = image[x_min_idx:x_max_idx, y_min_idx:y_max_idx, z_min_idx:z_max_idx]

        # **** Resample ****
        transform = sitk.Transform(3, sitk.sitkIdentity)
        reference_image = sitk.Image(classification_patch_size, patch_image.GetPixelIDValue())
        reference_image.SetOrigin(patch_image.GetOrigin())
        reference_image.SetDirection(patch_image.GetDirection())
        new_spacing = [(sz - 1) * spc / (nsz - 1) for nsz, sz, spc in
                       zip(classification_patch_size, patch_image.GetSize(),
                           patch_image.GetSpacing())]
        if not min(new_spacing) > 0:
            sh.print('BB', bounding_box,
                     (x_min_idx, x_max_idx, y_min_idx, y_max_idx, z_min_idx, z_max_idx))
            sh.print('new_spacing', new_spacing, 'classification_patch_size', classification_patch_size,
                     'patch_image.GetSize()', patch_image.GetSize(), 'patch_image.GetSpacing()',
                     patch_image.GetSpacing(), 'z_min_idx:z_max_idx', z_min_idx, z_max_idx)

        reference_image.SetSpacing(new_spacing)
        resampled_image = sitk.Resample(patch_image, reference_image, transform, interpolator)

        return resampled_image

    def get_patch_image_with_depth(self, image, centroid, bounding_box, classification_patch_size, patch_min_depth=9,
                                   pixeldefaultvalue=-1024, interpolator=sitk.sitkLinear):

        center = np.array([
            (bounding_box[0] + int(bounding_box[3] / 2)),
            (bounding_box[1] + int(bounding_box[4] / 2)),
            (bounding_box[2] + int(bounding_box[5] / 2))
        ])
        # print('center', center)

        half_patch_diam = 32
        z_depth = max(int(bounding_box[5] / 2), int(patch_min_depth / 2))

        # Calculate index
        x_min_idx = max(center[0] - half_patch_diam, 0)
        x_max_idx = min(center[0] + half_patch_diam, image.GetSize()[0])

        y_min_idx = max(center[1] - half_patch_diam, 0)
        y_max_idx = min(center[1] + half_patch_diam, image.GetSize()[1])

        z_min_idx = max(center[2] - z_depth, 0)
        z_max_idx = min((center[2] + z_depth) + 1, image.GetSize()[2])

        # print('patch size', bounding_box, (x_min_idx, x_max_idx, y_min_idx, y_max_idx, z_min_idx, z_max_idx))

        patch_image = image[x_min_idx:x_max_idx, y_min_idx:y_max_idx, z_min_idx:z_max_idx]

        # **** Resample ****
        transform = sitk.Transform(3, sitk.sitkIdentity)
        reference_image = sitk.Image(classification_patch_size, patch_image.GetPixelIDValue())
        reference_image.SetOrigin(patch_image.GetOrigin())
        reference_image.SetDirection(patch_image.GetDirection())
        new_spacing = [(sz - 1) * spc / (nsz - 1) for nsz, sz, spc in
                       zip(classification_patch_size, patch_image.GetSize(),
                           patch_image.GetSpacing())]

        reference_image.SetSpacing(new_spacing)
        resampled_image = sitk.Resample(patch_image, reference_image, transform, interpolator)

        return resampled_image
